#!/usr/bin/env python

# This script is intended to be compatible with both python2 and python3
from __future__ import print_function

from pygccxml import *

import os
import sys

def friendly_proxy_name(klass):
    if klass.name == 'StandardRecord': return 'SRProxy'

    return klass.name+'Proxy'


# Drop the allocator argument from vectors
def short_type(type):
    if not is_vector(type): return str(type)

    inner = vector_contents(type)
    if declarations.is_class(inner): inner = inner.name
    return 'std::vector<'+str(inner)+'>'


def members(klass):
    # Only accept direct members. Sort to keep .cxx and .h consistent
    return sorted([v for v in klass.variables(allow_empty = True) if v.parent == klass])


def base_class(klass):
    assert len(klass.bases) < 2, 'Support for multiple base classes not implemented'
    if len(klass.bases) == 1:
        return klass.bases[0].related_class
    return None


def members_inc_base(klass):
    ret = members(klass)
    # Recurse into base classes if necessary
    base = base_class(klass)
    if base: ret += members_inc_base(base)
    return ret


def is_template(type):
    return declarations.templates.is_instantiation(str(type))


def is_vector(type):
    if not is_template(type): return False

    return declarations.templates.name(str(type)) == 'std::vector'


def vector_contents(type):
    assert is_vector(type)

    return declarations.container_traits.vector_traits.element_type(type)


# -----------------------------------------------------------------------------
disclaimer = '''// This file was auto-generated by parse_xml.py.
// DO NOT EDIT IT DIRECTLY.
// For documentation of the fields see the regular StandardRecord.h'''

# -----------------------------------------------------------------------------
# Extra member functions for specfic classes.
class_to_addons = {
    'SRVector3D' : open('SRVector3DAddons.h').read(),
    'SRLorentzVector' : open('SRLorentzVectorAddons.h').read()
    }

# -----------------------------------------------------------------------------
hdr_prolog = '''{DISCLAIMER}

#pragma once
{PROLOG}
#include "StandardRecord/Proxy/BasicTypesProxy.h"

#include "StandardRecord/Proxy/FwdDeclare.h"

'''

# -----------------------------------------------------------------------------
hdr_body = '''
/// Proxy for \\ref {TYPE}
template<> class caf::Proxy<{TYPE}> {BASE}
{{
public:
  Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset);
  Proxy(const Proxy&) = delete;
  Proxy(const Proxy&&) = delete;
  Proxy& operator=(const {TYPE}& x);

  void CheckEquals(const {TYPE}& sr) const;
{ADDONS}
{MEMBERS}
}};
'''

# -----------------------------------------------------------------------------
cxx_prolog = '''{DISCLAIMER}

#include "StandardRecord/Proxy/SRProxy.h"

#include "{INPUT}"

namespace
{{
  std::string Join(const std::string& a, const std::string& b)
  {{
    if(a.empty()) return b;
    return a+"."+b;
  }}
}}
'''

# -----------------------------------------------------------------------------
cxx_body = '''
caf::Proxy<{TYPE}>::Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset) :
{INITS}
{{
}}

caf::Proxy<{TYPE}>& caf::Proxy<{TYPE}>::operator=(const {TYPE}& sr)
{{
{ASSIGN_BODY}
  return *this;
}}

void caf::Proxy<{TYPE}>::CheckEquals(const {TYPE}& sr) const
{{
{CHECKEQUALS_BODY}
}}
'''

# -----------------------------------------------------------------------------
fwd_prolog = '''{DISCLAIMER}

#pragma once

namespace caf
{{
  template<class T> class Proxy;
}}
'''

# -----------------------------------------------------------------------------
fwd_body = '''
namespace {NS}
{{
  class {TYPE};
  using {PTYPE} = caf::Proxy<{TYPE}>;
}}
'''
# -----------------------------------------------------------------------------

def full_namespace(type):
    ns = []
    while type.parent and type.parent.name != '::':
        ns = [type.parent.name]+ns
        type = type.parent
    return '::'.join(ns)


def full_name(type):
    return full_namespace(type)+'::'+type.name


def emit(klass):
    inits = []
    memstr = []

    base = base_class(klass)
    if base:
        inits += ['  caf::Proxy<{BTYPE}>(d, tr, name, base, offset)'.format(BTYPE = base.name)]

    for v in members(klass):
        inits += [ '  {NAME}(d, tr, Join(name, "{NAME}"), base, offset)'.format(NAME = v.name)]
        memstr += ['  caf::Proxy<{TYPE}> {NAME};'.format(TYPE = short_type(v.decl_type), NAME = v.name)]


    assign_body = []
    checkequals_body = []

    for v in members_inc_base(klass):
        assign_body += ['  {NAME} = sr.{NAME};'.format(NAME = v.name)]
        checkequals_body += ['  {NAME}.CheckEquals(sr.{NAME});'.format(NAME = v.name)]

    fcxx.write(cxx_body.format(TYPE = full_name(klass),
                               INITS = ',\n'.join(inits),
                               ASSIGN_BODY = '\n'.join(assign_body),
                               CHECKEQUALS_BODY = '\n'.join(checkequals_body)))

    ffwd.write(fwd_body.format(NS = full_namespace(klass),
                               TYPE = klass.name,
                               PTYPE = friendly_proxy_name(klass)))

    fhdr.write(hdr_body.format(TYPE = full_name(klass),
                               BASE = ': public Proxy<'+base.name+'>' if base else '',
                               ADDONS = class_to_addons[klass.name] if klass.name in class_to_addons else '',
                               MEMBERS = '\n'.join(memstr)))


already = set()
def recurse(klass):
    if not declarations.is_class(klass): return
    if declarations.is_std_string(klass): return

    if klass in already: return
    already.add(klass)

    base = base_class(klass)
    if base: recurse(base)

    for v in members(klass):
        if is_vector(v.decl_type):
            recurse(vector_contents(v.decl_type))
        elif declarations.is_array(v.decl_type):
            recurse(v.decl_type.base)
        else:
            if declarations.is_class(v.decl_type):
                recurse(v.decl_type.declaration)

    emit(klass)



if len(sys.argv) < 1 or len(sys.argv) > 3:
    print('Usage: parse_xml.py [/path/to/header/outputs/] [/path/to/cxx/outputs/]')
    sys.exit(1)

hdrDir = os.getcwd()
if len(sys.argv) >= 2: hdrDir = sys.argv[1]
cxxDir = os.getcwd()
if len(sys.argv) >= 3: cxxDir = sys.argv[2]

# Locate the castxml executable
generator_path, generator_name = utils.find_xml_generator()

# Figure out where our source files are
priv = os.environ['SRT_PRIVATE_CONTEXT'] if 'SRT_PRIVATE_CONTEXT' in os.environ else None
pub = os.environ['SRT_PUBLIC_CONTEXT'] if 'SRT_PUBLIC_CONTEXT' in os.environ else None

# For cmake build
if not pub: pub = os.environ['NOVASOFT_DIR']

context = priv if priv else pub

path = []
if priv: path += [priv]
path += [pub]
path += [os.environ['ROOT_INC']]

config = parser.xml_generator_configuration_t(
    xml_generator_path=generator_path,
    xml_generator=generator_name,
    include_paths=path,
    cflags='-std=c++1z -Wno-unknown-warning-option'
    )

input_header = 'StandardRecord/StandardRecord.h'

decls = parser.parse([context+'/'+input_header], config)

global_namespace = declarations.get_global_namespace(decls)

top = global_namespace.namespace('caf').class_('StandardRecord')


fcxx = open(cxxDir+'/SRProxy.cxx', 'w')
fhdr = open(hdrDir+'/SRProxy.h', 'w')
ffwd = open(hdrDir+'/FwdDeclare.h', 'w')

fcxx.write(cxx_prolog.format(DISCLAIMER = disclaimer,
                             INPUT = input_header))

fhdr.write(hdr_prolog.format(DISCLAIMER = disclaimer,
                             PROLOG = open('Prolog.h').read()))

ffwd.write(fwd_prolog.format(DISCLAIMER = disclaimer))


recurse(top)


print('Wrote SRProxy.h, FwdDeclare.h, SRProxy.cxx')
