#!/usr/bin/env python

# This script is intended to be compatible with both python2 and python3
from __future__ import print_function

import pygccxml

import argparse
import os
import sys

# Don't spam pygccxml deprecation warnings
import warnings
warnings.simplefilter(action = 'once', category = DeprecationWarning)

# Globals
fcxx = None
fhdr = None
ffwd = None

# Extra member functions for specfic classes.
class_to_addons = {}


def friendly_proxy_name(klass):
    return klass.name+'Proxy'


# Drop the allocator argument from vectors
def short_type(type):
    if not is_vector(type): return str(type)

    inner = vector_contents(type)
    if is_vector(inner): inner = short_type(inner)
    if pygccxml.declarations.is_class(inner): inner = full_name(inner)
    return 'std::vector<'+str(inner)+'>'


def members(klass):
    # Only accept direct members. Sort to keep .cxx and .h consistent
    return sorted([v for v in klass.variables(allow_empty = True) if v.parent == klass])


def base_class(klass):
    assert len(klass.bases) < 2, 'Support for multiple base classes not implemented'
    if len(klass.bases) == 1:
        return klass.bases[0].related_class
    return None


def is_template(type):
    return pygccxml.declarations.templates.is_instantiation(str(type))


def is_vector(type):
    if not is_template(type): return False

    return pygccxml.declarations.templates.name(str(type)) == 'std::vector'


def vector_contents(type):
    assert is_vector(type)

    return pygccxml.declarations.container_traits.vector_traits.element_type(type)


# -----------------------------------------------------------------------------
disclaimer = '''// This file was auto-generated by SRProxy's gen_srproxy.
// DO NOT EDIT IT DIRECTLY.'''

# -----------------------------------------------------------------------------
hdr_prolog = '''{DISCLAIMER}

#pragma once
{PROLOG}
#include "SRProxy/BasicTypesProxy.h"

#include "{OUTPATH}/FwdDeclare.h"

'''

# -----------------------------------------------------------------------------
hdr_body = '''
/// Proxy for \\ref {TYPE}
template<> class caf::Proxy<{TYPE}> {BASE}
{{
public:
  Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset);
  Proxy(const Proxy&) = delete;
  Proxy(const Proxy&&) = delete;
  Proxy& operator=(const {TYPE}& x);

  void CheckEquals(const {TYPE}& sr) const;
{ADDONS}
{MEMBERS}
}};
'''

# -----------------------------------------------------------------------------
cxx_prolog = '''{DISCLAIMER}

#include "{HEADER}"

#include "{INPUT}"

namespace
{{
  std::string Join(const std::string& a, const std::string& b)
  {{
    if(a.empty()) return b;
    return a+"."+b;
  }}
}}
'''

# -----------------------------------------------------------------------------
cxx_body = '''
caf::Proxy<{TYPE}>::Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset) :
{INITS}
{{
}}

caf::Proxy<{TYPE}>& caf::Proxy<{TYPE}>::operator=(const {TYPE}& sr)
{{
{ASSIGN_BODY}
  return *this;
}}

void caf::Proxy<{TYPE}>::CheckEquals(const {TYPE}& sr) const
{{
{CHECKEQUALS_BODY}
}}
'''

# -----------------------------------------------------------------------------
fwd_prolog = '''{DISCLAIMER}

#pragma once

namespace caf
{{
  template<class T> class Proxy;
}}
'''

# -----------------------------------------------------------------------------
fwd_body = '''
namespace {NS}
{{
  class {TYPE};
  using {PTYPE} = caf::Proxy<{TYPE}>;
}}
'''
# -----------------------------------------------------------------------------

def full_namespace(type):
    ns = []
    while type.parent and type.parent.name != '::':
        ns = [type.parent.name]+ns
        type = type.parent
    return '::'.join(ns)


def full_name(type):
    return full_namespace(type)+'::'+type.name


def emit(klass):
    inits = []
    memstr = []

    base = base_class(klass)
    if base:
        inits += ['  caf::Proxy<{BTYPE}>(d, tr, name, base, offset)'.format(BTYPE = short_type(base))]

    for v in members(klass):
        inits += [ '  {NAME}(d, tr, Join(name, "{NAME}"), base, offset)'.format(NAME = v.name)]
        memstr += ['  caf::Proxy<{TYPE}> {NAME};'.format(TYPE = short_type(v.decl_type), NAME = v.name)]


    assign_body = []
    checkequals_body = []

    for v in members(klass):
        assign_body += ['  {NAME} = sr.{NAME};'.format(NAME = v.name)]
        checkequals_body += ['  {NAME}.CheckEquals(sr.{NAME});'.format(NAME = v.name)]

    if base:
        assign_body += ['  caf::Proxy<{BTYPE}>::operator=(sr);'.format(BTYPE = short_type(base))]
        checkequals_body += ['  caf::Proxy<{BTYPE}>::CheckEquals(sr);'.format(BTYPE = short_type(base))]

    fcxx.write(cxx_body.format(TYPE = full_name(klass),
                               INITS = ',\n'.join(inits),
                               ASSIGN_BODY = '\n'.join(assign_body),
                               CHECKEQUALS_BODY = '\n'.join(checkequals_body)))

    ffwd.write(fwd_body.format(NS = full_namespace(klass),
                               TYPE = klass.name,
                               PTYPE = friendly_proxy_name(klass)))

    fhdr.write(hdr_body.format(TYPE = full_name(klass),
                               BASE = ': public Proxy<'+short_type(base)+'>' if base else '',
                               ADDONS = class_to_addons[klass.name] if klass.name in class_to_addons else '',
                               MEMBERS = '\n'.join(memstr)))


already = set()
def recurse(klass):
    if not pygccxml.declarations.is_class(klass): return
    if pygccxml.declarations.is_std_string(klass): return

    if klass in already: return
    already.add(klass)

    if is_vector(klass):
        recurse(vector_contents(klass))
        return

    base = base_class(klass)
    if base: recurse(base)

    for v in members(klass):
        if is_vector(v.decl_type):
            recurse(vector_contents(v.decl_type))
        elif pygccxml.declarations.is_array(v.decl_type):
            recurse(v.decl_type.base)
        else:
            if pygccxml.declarations.is_class(v.decl_type):
                recurse(v.decl_type.declaration)

    emit(klass)


def makeParser():
    parser = argparse.ArgumentParser()

    parser.add_argument('-i', '--input',
                        metavar = 'IN.h',
                        help = 'Input header (relative to --include-path)',
                        required = True)

    parser.add_argument('-o', '--output',
                        metavar = 'OUT',
                        help = 'Output file base name',
                        required = True)

    parser.add_argument('-t', '--target',
                        metavar = 'CLASS',
                        help = 'The name of the C++ type to be proxied',
                        required = True)

    parser.add_argument('-p', '--include-path',
                        metavar = 'PATH',
                        help = 'Colon-separated include path',
                        required = True)

    parser.add_argument('-op', '--output-path',
                        metavar = 'PATH',
                        help = 'Path for generated files to use to include each other',
                        required = True)

    parser.add_argument('--prolog',
                        metavar = 'FILE',
                        help = 'Specify a file to be included at the start of the generated header')

    parser.add_argument('--epilog',
                        metavar = 'FILE',
                        help = 'Specify a file to be included at the end of the generated header')

    parser.add_argument('--epilog-fwd',
                        metavar = 'FILE',
                        help = 'Specify a file to be included at the end of FwdDeclare.h')

    parser.add_argument('--extra',
                        metavar = ('CLASS', 'FILE'),
                        nargs = 2,
                        help = 'Include the contents of FILE in the declaration of the proxy for CLASS. Multiple allowed',
                        action = 'append')

    parser.add_argument('--extra-cflags',
                        metavar = 'FLAGS',
                        help = 'Extra options to pass to castxml compiler (in addition to -std=c++1z)',
                        default = '')

    return parser


def main():
    parser = makeParser()
    opts = vars(parser.parse_args())

    path = opts['include_path'].split(':')

    input_header = None
    for p in path:
        if os.path.isfile(p+'/'+opts['input']):
            input_header = p+'/'+opts['input']
            break

    if not input_header:
        print('Unable to find', opts['input'], 'in any of')
        for p in path: print('  '+p)
        sys.exit(1)


    target = opts['target'].split('::')

    # Locate the castxml executable
    generator_path, generator_name = pygccxml.utils.find_xml_generator()

    config = pygccxml.parser.xml_generator_configuration_t(
        xml_generator_path = generator_path,
        xml_generator = generator_name,
        include_paths = path,
        cflags = '-std=c++1z -Wno-unknown-warning-option '+opts['extra_cflags']
        )

    decls = pygccxml.parser.parse([input_header], config)

    top = pygccxml.declarations.get_global_namespace(decls)

    while len(target) > 1:
        top = top.namespace(target[0])
        target = target[1:]

    top = top.class_(target[0])


    if opts['extra']:
        for e in opts['extra']:
            class_to_addons[e[0]] = open(e[1]).read()


    global fcxx, fhdr, ffwd
    fcxx = open(opts['output']+'.cxx', 'w')
    fhdr = open(opts['output']+'.h', 'w')
    ffwd = open('FwdDeclare.h', 'w')

    fcxx.write(cxx_prolog.format(DISCLAIMER = disclaimer,
                                 INPUT = opts['input'],
                                 HEADER = opts['output_path']+'/'+opts['output']+'.h'))

    prolog = open(opts['prolog']).read() if opts['prolog'] else ''
    fhdr.write(hdr_prolog.format(DISCLAIMER = disclaimer,
                                 PROLOG = prolog,
                                 OUTPATH = opts['output_path']))

    ffwd.write(fwd_prolog.format(DISCLAIMER = disclaimer))

    recurse(top)

    if opts['epilog']: fhdr.write(open(opts['epilog']).read())

    if opts['epilog_fwd']: ffwd.write(open(opts['epilog_fwd']).read())

    print('Wrote '+fhdr.name+', '+ffwd.name+', '+fcxx.name)


if __name__ == '__main__':
    main()
