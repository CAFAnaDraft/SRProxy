#!/usr/bin/env python

# This script is intended to be compatible with both python2 and python3
from __future__ import print_function

import pygccxml

import argparse
import os
import sys

# Don't spam pygccxml deprecation warnings
import warnings
warnings.simplefilter(action = 'once', category = DeprecationWarning)

# Globals
fcxx = None
fhdr = None
ffwd = None

gFlat = True

# Extra member functions for specfic classes.
class_to_addons = {}


def friendly_proxy_name(klass):
    return klass.name+'Proxy'


def friendly_flat_name(klass):
    return 'Flat'+klass.name


# Drop the allocator argument from vectors
def short_type(type):
    if not is_vector(type):
        if hasattr(type, 'name'): return full_name(type)
        return str(type)

    inner = vector_contents(type)
    if is_vector(inner): inner = short_type(inner)
    if pygccxml.declarations.is_class(inner): inner = full_name(inner)
    return 'std::vector<'+str(inner)+'>'

def members(klass):
    # Only accept direct members. Sort to keep .cxx and .h consistent
    return sorted([v for v in klass.variables(allow_empty = True) if v.parent == klass])


def base_class(klass):
    assert len(klass.bases) < 2, 'Support for multiple base classes not implemented'
    if len(klass.bases) == 1:
        return klass.bases[0].related_class
    return None


def is_template(type):
    return pygccxml.declarations.templates.is_instantiation(str(type))


def is_vector(type):
    if not is_template(type): return False

    return pygccxml.declarations.templates.name(str(type)) == 'std::vector'


def vector_contents(type):
    assert is_vector(type)

    return pygccxml.declarations.container_traits.vector_traits.element_type(type)


# -----------------------------------------------------------------------------
disclaimer = '''// This file was auto-generated by SRProxy's gen_srproxy.
// DO NOT EDIT IT DIRECTLY.'''

# -----------------------------------------------------------------------------
proxy_hdr_prolog = '''{DISCLAIMER}

#pragma once
{PROLOG}
#include "SRProxy/BasicTypesProxy.h"

#include "{OUTPATH}/FwdDeclare.h"

'''

flat_hdr_prolog = '''{DISCLAIMER}

#pragma once
{PROLOG}
#include "FlatMaker/BasicTypeFlat.h"

#include "{OUTPATH}/FwdDeclare.h"

'''

hdr_prolog = flat_hdr_prolog if gFlat else proxy_hdr_prolog

# -----------------------------------------------------------------------------
proxy_hdr_body = '''
/// Proxy for \\ref {TYPE}
template<> class caf::Proxy<{TYPE}>{BASE}
{{
public:
  Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset);
  Proxy(const Proxy&) = delete;
  Proxy(const Proxy&&) = delete;
  Proxy& operator=(const {TYPE}& x);

  void CheckEquals(const {TYPE}& sr) const;
{ADDONS}
{MEMBERS}
}};
'''

flat_hdr_body = '''
/// Flat encoding of \\ref {TYPE}
template<> class flat::Flat<{TYPE}>{BASE}
{{
public:
  Flat(TTree* tr, const std::string& prefix, const std::string& totsize, const IBranchPolicy* policy);

  void Fill(const {TYPE}& sr);
  void Clear();

protected:
{MEMBERS}
}};
'''

hdr_body = flat_hdr_body if gFlat else proxy_hdr_body

# -----------------------------------------------------------------------------
proxy_cxx_prolog = '''{DISCLAIMER}

#include "{HEADER}"

#include "{INPUT}"

namespace
{{
  std::string Join(const std::string& a, const std::string& b)
  {{
    if(a.empty()) return b;
    return a+"."+b;
  }}
}}
'''

flat_cxx_prolog = '''{DISCLAIMER}

#include "{HEADER}"

#include "{INPUT}"
'''

cxx_prolog = flat_cxx_prolog if gFlat else proxy_cxx_prolog

# -----------------------------------------------------------------------------
proxy_cxx_body = '''
caf::Proxy<{TYPE}>::Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset) :
{INITS}
{{
}}

caf::Proxy<{TYPE}>& caf::Proxy<{TYPE}>::operator=(const {TYPE}& sr)
{{
{ASSIGN_BODY}
  return *this;
}}

void caf::Proxy<{TYPE}>::CheckEquals(const {TYPE}& sr) const
{{
{CHECKEQUALS_BODY}
}}
'''

flat_cxx_body = '''
flat::Flat<{TYPE}>::Flat(TTree* tr, const std::string& prefix, const std::string& totsize, const IBranchPolicy* policy) :
{INITS}
{{
}}

void flat::Flat<{TYPE}>::Fill(const {TYPE}& sr)
{{
{FILL_BODY}
}}

void flat::Flat<{TYPE}>::Clear()
{{
{CLEAR_BODY}
}}
'''

cxx_body = flat_cxx_body if gFlat else proxy_cxx_body

# -----------------------------------------------------------------------------
proxy_fwd_prolog = '''{DISCLAIMER}

#pragma once

namespace caf
{{
  template<class T> class Proxy;
}}
'''

flat_fwd_prolog = '''{DISCLAIMER}

#pragma once

namespace flat
{{
  template<class T> class Flat;
}}
'''

fwd_prolog = flat_fwd_prolog if gFlat else proxy_fwd_prolog

# -----------------------------------------------------------------------------
proxy_fwd_body = '''
namespace {NS}
{{
  class {TYPE};
  using {PTYPE} = caf::Proxy<{TYPE}>;
}}
'''

flat_fwd_body = '''
namespace {NS}
{{
  class {TYPE};
  using {PTYPE} = flat::Flat<{TYPE}>;
}}
'''

fwd_body = flat_fwd_body if gFlat else proxy_fwd_body

# -----------------------------------------------------------------------------

def full_namespace(type):
    ns = []
    while type.parent and type.parent.name != '::':
        ns = [type.parent.name]+ns
        type = type.parent
    return '::'.join(ns)


def full_name(type):
    return full_namespace(type)+'::'+type.name


def emit(klass):
    proxy_inits = []
    memstr = []
    flat_inits = []
    flat_memstr = []
    fill_body = []
    clear_body = []

    base = base_class(klass)
    if base:
        proxy_inits += ['  caf::Proxy<{BTYPE}>(d, tr, name, base, offset)'.format(BTYPE = short_type(base))]
        flat_inits += ['  flat::Flat<{BTYPE}>(tr, prefix, totsize, policy)'.format(BTYPE = short_type(base))]
        fill_body += ['  Flat<{BTYPE}>::Fill(sr);'.format(BTYPE = short_type(base))]
        clear_body += ['  Flat<{BTYPE}>::Clear();'.format(BTYPE = short_type(base))]

    for v in members(klass):
        proxy_inits += [ '  {NAME}(d, tr, Join(name, "{NAME}"), base, offset)'.format(NAME = v.name)]
        flat_inits += [ '  {NAME}(tr, prefix+".{NAME}", totsize, policy)'.format(NAME = v.name)]

        memstr += ['  caf::Proxy<{TYPE}> {NAME};'.format(TYPE = short_type(v.decl_type), NAME = v.name)]
        flat_memstr += ['  flat::Flat<{TYPE}> {NAME};'.format(TYPE = short_type(v.decl_type), NAME = v.name)]

        fill_body += ['  {NAME}.Fill(sr.{NAME});'.format(NAME = v.name)]
        clear_body += ['  {NAME}.Clear();'.format(NAME = v.name)]


    assign_body = []
    checkequals_body = []

    for v in members(klass):
        assign_body += ['  {NAME} = sr.{NAME};'.format(NAME = v.name)]
        checkequals_body += ['  {NAME}.CheckEquals(sr.{NAME});'.format(NAME = v.name)]

    if base:
        assign_body += ['  caf::Proxy<{BTYPE}>::operator=(sr);'.format(BTYPE = short_type(base))]
        checkequals_body += ['  caf::Proxy<{BTYPE}>::CheckEquals(sr);'.format(BTYPE = short_type(base))]

    inits = flat_inits if gFlat else proxy_inits

    fcxx.write(cxx_body.format(# Shared
                               TYPE = full_name(klass),
                               INITS = ',\n'.join(inits),
                               # For Proxy
                               ASSIGN_BODY = '\n'.join(assign_body),
                               CHECKEQUALS_BODY = '\n'.join(checkequals_body),
                               # For Flat
                               FILL_BODY = '\n'.join(fill_body),
                               CLEAR_BODY = '\n'.join(clear_body)))

    ffwd.write(fwd_body.format(NS = full_namespace(klass),
                               TYPE = klass.name,
                               PTYPE = friendly_proxy_name(klass)))

    if not gFlat:
        fhdr.write(hdr_body.format(TYPE = full_name(klass),
                                   BASE = ' : public Proxy<'+short_type(base)+'>' if base else '',
                                   ADDONS = class_to_addons[klass.name] if klass.name in class_to_addons else '',
                                   MEMBERS = '\n'.join(memstr)))
    else:
        fhdr.write(hdr_body.format(TYPE = full_name(klass),
                                   BASE = ' : public Flat<'+short_type(base)+'>' if base else '',
                                   MEMBERS = '\n'.join(flat_memstr)))


already = set()
def recurse(klass):
    if not pygccxml.declarations.is_class(klass): return
    if pygccxml.declarations.is_std_string(klass): return

    if klass in already: return
    already.add(klass)

    if is_vector(klass):
        recurse(vector_contents(klass))
        return

    base = base_class(klass)
    if base: recurse(base)

    for v in members(klass):
        if is_vector(v.decl_type):
            recurse(vector_contents(v.decl_type))
        elif pygccxml.declarations.is_array(v.decl_type):
            recurse(v.decl_type.base)
        else:
            if pygccxml.declarations.is_class(v.decl_type):
                recurse(v.decl_type.declaration)

    emit(klass)


def makeParser():
    parser = argparse.ArgumentParser()

    parser.add_argument('-i', '--input',
                        metavar = 'IN.h',
                        help = 'Input header (relative to --include-path)',
                        required = True)

    parser.add_argument('-o', '--output',
                        metavar = 'OUT',
                        help = 'Output file base name',
                        required = True)

    parser.add_argument('-t', '--target',
                        metavar = 'CLASS',
                        help = 'The name of the C++ type to be proxied',
                        required = True)

    parser.add_argument('-p', '--include-path',
                        metavar = 'PATH',
                        help = 'Colon-separated include path',
                        required = True)

    parser.add_argument('-op', '--output-path',
                        metavar = 'PATH',
                        help = 'Path for generated files to use to include each other',
                        required = True)

    parser.add_argument('--prolog',
                        metavar = 'FILE',
                        help = 'Specify a file to be included at the start of the generated header')

    parser.add_argument('--epilog',
                        metavar = 'FILE',
                        help = 'Specify a file to be included at the end of the generated header')

    parser.add_argument('--epilog-fwd',
                        metavar = 'FILE',
                        help = 'Specify a file to be included at the end of FwdDeclare.h')

    parser.add_argument('--extra',
                        metavar = ('CLASS', 'FILE'),
                        nargs = 2,
                        help = 'Include the contents of FILE in the declaration of the proxy for CLASS. Multiple allowed',
                        action = 'append')

    parser.add_argument('--extra-cflags',
                        metavar = 'FLAGS',
                        help = 'Extra options to pass to castxml compiler (in addition to -std=c++1z)',
                        default = '')

    return parser


def main():
    parser = makeParser()
    opts = vars(parser.parse_args())

    path = opts['include_path'].split(':')

    input_header = None
    for p in path:
        if os.path.isfile(p+'/'+opts['input']):
            input_header = p+'/'+opts['input']
            break

    if not input_header:
        print('Unable to find', opts['input'], 'in any of')
        for p in path: print('  '+p)
        sys.exit(1)


    target = opts['target'].split('::')

    # Locate the castxml executable
    generator_path, generator_name = pygccxml.utils.find_xml_generator()

    config = pygccxml.parser.xml_generator_configuration_t(
        xml_generator_path = generator_path,
        xml_generator = generator_name,
        include_paths = path,
        cflags = '-std=c++1z -Wno-unknown-warning-option '+opts['extra_cflags']
        )

    decls = pygccxml.parser.parse([input_header], config)

    top = pygccxml.declarations.get_global_namespace(decls)

    while len(target) > 1:
        top = top.namespace(target[0])
        target = target[1:]

    top = top.class_(target[0])


    if opts['extra']:
        for e in opts['extra']:
            class_to_addons[e[0]] = open(e[1]).read()


    global fcxx, fhdr, ffwd
    fcxx = open(opts['output']+'.cxx', 'w')
    fhdr = open(opts['output']+'.h', 'w')
    ffwd = open('FwdDeclare.h', 'w')

    fcxx.write(cxx_prolog.format(DISCLAIMER = disclaimer,
                                 INPUT = opts['input'],
                                 HEADER = opts['output_path']+'/'+opts['output']+'.h'))

    prolog = open(opts['prolog']).read() if opts['prolog'] else ''
    fhdr.write(hdr_prolog.format(DISCLAIMER = disclaimer,
                                 PROLOG = prolog,
                                 OUTPATH = opts['output_path']))

    ffwd.write(fwd_prolog.format(DISCLAIMER = disclaimer))

    recurse(top)

    if opts['epilog']: fhdr.write(open(opts['epilog']).read())

    if opts['epilog_fwd']: ffwd.write(open(opts['epilog_fwd']).read())

    print('Wrote '+fhdr.name+', '+ffwd.name+', '+fcxx.name)


if __name__ == '__main__':
    main()
